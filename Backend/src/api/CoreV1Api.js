/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.30.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import IoK8sApiAuthenticationV1TokenRequest from '../model/IoK8sApiAuthenticationV1TokenRequest';
import IoK8sApiAutoscalingV1Scale from '../model/IoK8sApiAutoscalingV1Scale';
import IoK8sApiCoreV1Binding from '../model/IoK8sApiCoreV1Binding';
import IoK8sApiCoreV1ComponentStatus from '../model/IoK8sApiCoreV1ComponentStatus';
import IoK8sApiCoreV1ComponentStatusList from '../model/IoK8sApiCoreV1ComponentStatusList';
import IoK8sApiCoreV1ConfigMap from '../model/IoK8sApiCoreV1ConfigMap';
import IoK8sApiCoreV1ConfigMapList from '../model/IoK8sApiCoreV1ConfigMapList';
import IoK8sApiCoreV1Endpoints from '../model/IoK8sApiCoreV1Endpoints';
import IoK8sApiCoreV1EndpointsList from '../model/IoK8sApiCoreV1EndpointsList';
import IoK8sApiCoreV1Event from '../model/IoK8sApiCoreV1Event';
import IoK8sApiCoreV1EventList from '../model/IoK8sApiCoreV1EventList';
import IoK8sApiCoreV1LimitRange from '../model/IoK8sApiCoreV1LimitRange';
import IoK8sApiCoreV1LimitRangeList from '../model/IoK8sApiCoreV1LimitRangeList';
import IoK8sApiCoreV1Namespace from '../model/IoK8sApiCoreV1Namespace';
import IoK8sApiCoreV1NamespaceList from '../model/IoK8sApiCoreV1NamespaceList';
import IoK8sApiCoreV1Node from '../model/IoK8sApiCoreV1Node';
import IoK8sApiCoreV1NodeList from '../model/IoK8sApiCoreV1NodeList';
import IoK8sApiCoreV1PersistentVolume from '../model/IoK8sApiCoreV1PersistentVolume';
import IoK8sApiCoreV1PersistentVolumeClaim from '../model/IoK8sApiCoreV1PersistentVolumeClaim';
import IoK8sApiCoreV1PersistentVolumeClaimList from '../model/IoK8sApiCoreV1PersistentVolumeClaimList';
import IoK8sApiCoreV1PersistentVolumeList from '../model/IoK8sApiCoreV1PersistentVolumeList';
import IoK8sApiCoreV1Pod from '../model/IoK8sApiCoreV1Pod';
import IoK8sApiCoreV1PodList from '../model/IoK8sApiCoreV1PodList';
import IoK8sApiCoreV1PodTemplate from '../model/IoK8sApiCoreV1PodTemplate';
import IoK8sApiCoreV1PodTemplateList from '../model/IoK8sApiCoreV1PodTemplateList';
import IoK8sApiCoreV1ReplicationController from '../model/IoK8sApiCoreV1ReplicationController';
import IoK8sApiCoreV1ReplicationControllerList from '../model/IoK8sApiCoreV1ReplicationControllerList';
import IoK8sApiCoreV1ResourceQuota from '../model/IoK8sApiCoreV1ResourceQuota';
import IoK8sApiCoreV1ResourceQuotaList from '../model/IoK8sApiCoreV1ResourceQuotaList';
import IoK8sApiCoreV1Secret from '../model/IoK8sApiCoreV1Secret';
import IoK8sApiCoreV1SecretList from '../model/IoK8sApiCoreV1SecretList';
import IoK8sApiCoreV1Service from '../model/IoK8sApiCoreV1Service';
import IoK8sApiCoreV1ServiceAccount from '../model/IoK8sApiCoreV1ServiceAccount';
import IoK8sApiCoreV1ServiceAccountList from '../model/IoK8sApiCoreV1ServiceAccountList';
import IoK8sApiCoreV1ServiceList from '../model/IoK8sApiCoreV1ServiceList';
import IoK8sApiPolicyV1Eviction from '../model/IoK8sApiPolicyV1Eviction';
import IoK8sApimachineryPkgApisMetaV1APIResourceList from '../model/IoK8sApimachineryPkgApisMetaV1APIResourceList';
import IoK8sApimachineryPkgApisMetaV1DeleteOptions from '../model/IoK8sApimachineryPkgApisMetaV1DeleteOptions';
import IoK8sApimachineryPkgApisMetaV1Status from '../model/IoK8sApimachineryPkgApisMetaV1Status';
import IoK8sApimachineryPkgApisMetaV1WatchEvent from '../model/IoK8sApimachineryPkgApisMetaV1WatchEvent';

/**
* CoreV1 service.
* @module api/CoreV1Api
* @version v1.30.0
*/
export default class CoreV1Api {

    /**
    * Constructs a new CoreV1Api. 
    * @alias module:api/CoreV1Api
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the connectCoreV1DeleteNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1DeleteNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1DeleteNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1DeleteNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1DeleteNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1DeleteNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1DeleteNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1DeleteNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1DeleteNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1DeleteNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1DeleteNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1DeleteNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1DeleteNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1DeleteNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1DeleteNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1DeleteNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1DeleteNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1DeleteNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1DeleteNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1DeleteNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1DeleteNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1DeleteNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1DeleteNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1DeleteNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1DeleteNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1DeleteNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1DeleteNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1DeleteNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1DeleteNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1DeleteNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1DeleteNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect DELETE requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1DeleteNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1DeleteNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1DeleteNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedPodAttach operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedPodAttachCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to attach of Pod
     * @param {String} name name of the PodAttachOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [container] The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} [stderr] Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} [stdin] Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} [stdout] Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} [tty] TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedPodAttachCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedPodAttach(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedPodAttach");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedPodAttach");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/attach', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedPodExec operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedPodExecCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to exec of Pod
     * @param {String} name name of the PodExecOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [command] Command is the remote command to execute. argv array. Not executed within a shell.
     * @param {String} [container] Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} [stderr] Redirect the standard error stream of the pod for this call.
     * @param {Boolean} [stdin] Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} [stdout] Redirect the standard output stream of the pod for this call.
     * @param {Boolean} [tty] TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedPodExecCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedPodExec(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedPodExec");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedPodExec");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'command': opts['command'],
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/exec', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedPodPortforward operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedPodPortforwardCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to portforward of Pod
     * @param {String} name name of the PodPortForwardOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Number} [ports] List of ports to forward Required when using WebSockets
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedPodPortforwardCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedPodPortforward(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedPodPortforward");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedPodPortforward");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'ports': opts['ports']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/portforward', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1GetNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1GetNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1GetNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1GetNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1GetNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect GET requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1GetNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1GetNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1GetNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1HeadNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1HeadNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1HeadNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1HeadNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1HeadNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1HeadNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1HeadNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1HeadNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1HeadNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1HeadNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1HeadNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1HeadNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1HeadNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1HeadNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1HeadNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1HeadNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1HeadNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1HeadNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1HeadNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1HeadNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1HeadNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1HeadNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1HeadNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1HeadNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1HeadNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1HeadNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1HeadNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1HeadNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1HeadNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1HeadNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1HeadNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect HEAD requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1HeadNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1HeadNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1HeadNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'HEAD',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1OptionsNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1OptionsNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1OptionsNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1OptionsNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1OptionsNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1OptionsNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1OptionsNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1OptionsNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1OptionsNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1OptionsNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1OptionsNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1OptionsNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1OptionsNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1OptionsNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1OptionsNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1OptionsNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1OptionsNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1OptionsNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1OptionsNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1OptionsNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1OptionsNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1OptionsNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1OptionsNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1OptionsNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1OptionsNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1OptionsNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1OptionsNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1OptionsNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1OptionsNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1OptionsNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1OptionsNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect OPTIONS requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1OptionsNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1OptionsNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1OptionsNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'OPTIONS',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PatchNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PatchNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1PatchNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PatchNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PatchNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PatchNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PatchNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PatchNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1PatchNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PatchNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PatchNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PatchNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PatchNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PatchNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1PatchNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PatchNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PatchNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PatchNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PatchNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PatchNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1PatchNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PatchNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PatchNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PatchNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PatchNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PatchNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1PatchNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PatchNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PatchNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PatchNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PatchNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PATCH requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1PatchNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PatchNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PatchNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedPodAttach operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedPodAttachCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to attach of Pod
     * @param {String} name name of the PodAttachOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [container] The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} [stderr] Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} [stdin] Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} [stdout] Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param {Boolean} [tty] TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedPodAttachCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedPodAttach(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedPodAttach");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedPodAttach");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/attach', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedPodExec operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedPodExecCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to exec of Pod
     * @param {String} name name of the PodExecOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [command] Command is the remote command to execute. argv array. Not executed within a shell.
     * @param {String} [container] Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param {Boolean} [stderr] Redirect the standard error stream of the pod for this call.
     * @param {Boolean} [stdin] Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param {Boolean} [stdout] Redirect the standard output stream of the pod for this call.
     * @param {Boolean} [tty] TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedPodExecCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedPodExec(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedPodExec");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedPodExec");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'command': opts['command'],
        'container': opts['container'],
        'stderr': opts['stderr'],
        'stdin': opts['stdin'],
        'stdout': opts['stdout'],
        'tty': opts['tty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/exec', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedPodPortforward operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedPodPortforwardCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to portforward of Pod
     * @param {String} name name of the PodPortForwardOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Number} [ports] List of ports to forward Required when using WebSockets
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedPodPortforwardCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedPodPortforward(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedPodPortforward");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedPodPortforward");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'ports': opts['ports']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/portforward', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1PostNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PostNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1PostNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PostNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PostNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect POST requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1PostNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PostNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PostNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PutNamespacedPodProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PutNamespacedPodProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1PutNamespacedPodProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PutNamespacedPodProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PutNamespacedPodProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PutNamespacedPodProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PutNamespacedPodProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PutNamespacedPodProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Pod
     * @param {String} name name of the PodProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to pod.
     * @param {module:api/CoreV1Api~connectCoreV1PutNamespacedPodProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PutNamespacedPodProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PutNamespacedPodProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PutNamespacedPodProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PutNamespacedServiceProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PutNamespacedServiceProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1PutNamespacedServiceProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PutNamespacedServiceProxy(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PutNamespacedServiceProxy");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PutNamespacedServiceProxy");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PutNamespacedServiceProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PutNamespacedServiceProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Service
     * @param {String} name name of the ServiceProxyOptions
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @param {module:api/CoreV1Api~connectCoreV1PutNamespacedServiceProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PutNamespacedServiceProxyWithPath(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PutNamespacedServiceProxyWithPath");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling connectCoreV1PutNamespacedServiceProxyWithPath");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PutNodeProxy operation.
     * @callback module:api/CoreV1Api~connectCoreV1PutNodeProxyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1PutNodeProxyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PutNodeProxy(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PutNodeProxy");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the connectCoreV1PutNodeProxyWithPath operation.
     * @callback module:api/CoreV1Api~connectCoreV1PutNodeProxyWithPathCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * connect PUT requests to proxy of Node
     * @param {String} name name of the NodeProxyOptions
     * @param {Object} opts Optional parameters
     * @param {String} [path] Path is the URL path to use for the current proxy request to node.
     * @param {module:api/CoreV1Api~connectCoreV1PutNodeProxyWithPathCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    connectCoreV1PutNodeProxyWithPath(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling connectCoreV1PutNodeProxyWithPath");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'path': opts['path']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/proxy/{path}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Namespace
     * @param {module:model/IoK8sApiCoreV1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    createCoreV1Namespace(body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1Namespace");
      }

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedBinding operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedBindingCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Binding} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Binding
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Binding} body 
     * @param {Object} opts Optional parameters
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~createCoreV1NamespacedBindingCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Binding}
     */
    createCoreV1NamespacedBinding(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedBinding");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedBinding");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Binding;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/bindings', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ConfigMap} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ConfigMap}
     */
    createCoreV1NamespacedConfigMap(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ConfigMap;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Endpoints} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Endpoints}
     */
    createCoreV1NamespacedEndpoints(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Endpoints;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create an Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Event} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Event}
     */
    createCoreV1NamespacedEvent(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedEvent");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedEvent");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Event;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1LimitRange} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1LimitRange}
     */
    createCoreV1NamespacedLimitRange(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1LimitRange;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    createCoreV1NamespacedPersistentVolumeClaim(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    createCoreV1NamespacedPod(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedPod");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedPod");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedPodBinding operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedPodBindingCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Binding} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create binding of a Pod
     * @param {String} name name of the Binding
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Binding} body 
     * @param {Object} opts Optional parameters
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~createCoreV1NamespacedPodBindingCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Binding}
     */
    createCoreV1NamespacedPodBinding(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling createCoreV1NamespacedPodBinding");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedPodBinding");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedPodBinding");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Binding;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/binding', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedPodEviction operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedPodEvictionCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiPolicyV1Eviction} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create eviction of a Pod
     * @param {String} name name of the Eviction
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiPolicyV1Eviction} body 
     * @param {Object} opts Optional parameters
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~createCoreV1NamespacedPodEvictionCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiPolicyV1Eviction}
     */
    createCoreV1NamespacedPodEviction(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling createCoreV1NamespacedPodEviction");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedPodEviction");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedPodEviction");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiPolicyV1Eviction;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/eviction', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1PodTemplate} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplate}
     */
    createCoreV1NamespacedPodTemplate(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PodTemplate;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ReplicationController} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    createCoreV1NamespacedReplicationController(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    createCoreV1NamespacedResourceQuota(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Secret} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Secret}
     */
    createCoreV1NamespacedSecret(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedSecret");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedSecret");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Secret;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Service} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    createCoreV1NamespacedService(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedService");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedService");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccount}
     */
    createCoreV1NamespacedServiceAccount(namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ServiceAccount;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1NamespacedServiceAccountToken operation.
     * @callback module:api/CoreV1Api~createCoreV1NamespacedServiceAccountTokenCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiAuthenticationV1TokenRequest} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create token of a ServiceAccount
     * @param {String} name name of the TokenRequest
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiAuthenticationV1TokenRequest} body 
     * @param {Object} opts Optional parameters
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~createCoreV1NamespacedServiceAccountTokenCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiAuthenticationV1TokenRequest}
     */
    createCoreV1NamespacedServiceAccountToken(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling createCoreV1NamespacedServiceAccountToken");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createCoreV1NamespacedServiceAccountToken");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1NamespacedServiceAccountToken");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiAuthenticationV1TokenRequest;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1Node operation.
     * @callback module:api/CoreV1Api~createCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a Node
     * @param {module:model/IoK8sApiCoreV1Node} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    createCoreV1Node(body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1Node");
      }

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~createCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a PersistentVolume
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~createCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    createCoreV1PersistentVolume(body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoreV1PersistentVolume");
      }

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedConfigMap(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedConfigMap");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedEndpoints(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedEndpoints");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedEvent operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedEvent(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedEvent");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedLimitRange(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedLimitRange");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedPersistentVolumeClaim(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedPod operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedPod(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedPod");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedPodTemplate(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedPodTemplate");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedReplicationController(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedReplicationController");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedResourceQuota(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedResourceQuota");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedSecret operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedSecret(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedSecret");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedService operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedService(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedService");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNamespacedServiceAccount(namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1CollectionNamespacedServiceAccount");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionNode operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionNodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of Node
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionNodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionNode(opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/nodes', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1CollectionPersistentVolume operation.
     * @callback module:api/CoreV1Api~deleteCoreV1CollectionPersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete collection of PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1CollectionPersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1CollectionPersistentVolume(opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'continue': opts['_continue'],
        'dryRun': opts['dryRun'],
        'fieldSelector': opts['fieldSelector'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Namespace
     * @param {String} name name of the Namespace
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1Namespace(name, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1Namespace");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1NamespacedConfigMap(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1NamespacedEndpoints(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete an Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1NamespacedEvent(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedEvent");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedEvent");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1NamespacedLimitRange(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    deleteCoreV1NamespacedPersistentVolumeClaim(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    deleteCoreV1NamespacedPod(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedPod");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedPod");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplate}
     */
    deleteCoreV1NamespacedPodTemplate(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PodTemplate;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1NamespacedReplicationController(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    deleteCoreV1NamespacedResourceQuota(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1NamespacedSecret(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedSecret");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedSecret");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    deleteCoreV1NamespacedService(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedService");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedService");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccount}
     */
    deleteCoreV1NamespacedServiceAccount(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ServiceAccount;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1Node operation.
     * @callback module:api/CoreV1Api~deleteCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1Status} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1Status}
     */
    deleteCoreV1Node(name, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1Node");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1Status;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~deleteCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * delete a PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {Number} [gracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param {Boolean} [orphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param {String} [propagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1DeleteOptions} [body] 
     * @param {module:api/CoreV1Api~deleteCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    deleteCoreV1PersistentVolume(name, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling deleteCoreV1PersistentVolume");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'gracePeriodSeconds': opts['gracePeriodSeconds'],
        'orphanDependents': opts['orphanDependents'],
        'propagationPolicy': opts['propagationPolicy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getCoreV1APIResources operation.
     * @callback module:api/CoreV1Api~getCoreV1APIResourcesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1APIResourceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * get available resources
     * @param {module:api/CoreV1Api~getCoreV1APIResourcesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1APIResourceList}
     */
    getCoreV1APIResources(callback) {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApimachineryPkgApisMetaV1APIResourceList;
      return this.apiClient.callApi(
        '/api/v1/', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1ComponentStatus operation.
     * @callback module:api/CoreV1Api~listCoreV1ComponentStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ComponentStatusList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list objects of kind ComponentStatus
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1ComponentStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ComponentStatusList}
     */
    listCoreV1ComponentStatus(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ComponentStatusList;
      return this.apiClient.callApi(
        '/api/v1/componentstatuses', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1ConfigMapForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1ConfigMapForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ConfigMapList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ConfigMap
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1ConfigMapForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ConfigMapList}
     */
    listCoreV1ConfigMapForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ConfigMapList;
      return this.apiClient.callApi(
        '/api/v1/configmaps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1EndpointsForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1EndpointsForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1EndpointsList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Endpoints
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1EndpointsForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1EndpointsList}
     */
    listCoreV1EndpointsForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1EndpointsList;
      return this.apiClient.callApi(
        '/api/v1/endpoints', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1EventForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1EventForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1EventList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Event
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1EventForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1EventList}
     */
    listCoreV1EventForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1EventList;
      return this.apiClient.callApi(
        '/api/v1/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1LimitRangeForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1LimitRangeForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1LimitRangeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind LimitRange
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1LimitRangeForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1LimitRangeList}
     */
    listCoreV1LimitRangeForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1LimitRangeList;
      return this.apiClient.callApi(
        '/api/v1/limitranges', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1NamespaceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Namespace
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1NamespaceList}
     */
    listCoreV1Namespace(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1NamespaceList;
      return this.apiClient.callApi(
        '/api/v1/namespaces', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ConfigMapList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ConfigMapList}
     */
    listCoreV1NamespacedConfigMap(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ConfigMapList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1EndpointsList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1EndpointsList}
     */
    listCoreV1NamespacedEndpoints(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1EndpointsList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1EventList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1EventList}
     */
    listCoreV1NamespacedEvent(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedEvent");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1EventList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1LimitRangeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1LimitRangeList}
     */
    listCoreV1NamespacedLimitRange(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1LimitRangeList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaimList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaimList}
     */
    listCoreV1NamespacedPersistentVolumeClaim(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaimList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodList}
     */
    listCoreV1NamespacedPod(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedPod");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PodList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplateList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplateList}
     */
    listCoreV1NamespacedPodTemplate(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PodTemplateList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationControllerList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationControllerList}
     */
    listCoreV1NamespacedReplicationController(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ReplicationControllerList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuotaList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuotaList}
     */
    listCoreV1NamespacedResourceQuota(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ResourceQuotaList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1SecretList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1SecretList}
     */
    listCoreV1NamespacedSecret(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedSecret");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1SecretList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceList}
     */
    listCoreV1NamespacedService(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedService");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ServiceList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~listCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccountList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccountList}
     */
    listCoreV1NamespacedServiceAccount(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ServiceAccountList;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1Node operation.
     * @callback module:api/CoreV1Api~listCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1NodeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Node
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1NodeList}
     */
    listCoreV1Node(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1NodeList;
      return this.apiClient.callApi(
        '/api/v1/nodes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~listCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeList}
     */
    listCoreV1PersistentVolume(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PersistentVolumeList;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1PersistentVolumeClaimForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1PersistentVolumeClaimForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaimList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1PersistentVolumeClaimForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaimList}
     */
    listCoreV1PersistentVolumeClaimForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaimList;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumeclaims', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1PodForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1PodForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Pod
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1PodForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodList}
     */
    listCoreV1PodForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PodList;
      return this.apiClient.callApi(
        '/api/v1/pods', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1PodTemplateForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1PodTemplateForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplateList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind PodTemplate
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1PodTemplateForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplateList}
     */
    listCoreV1PodTemplateForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1PodTemplateList;
      return this.apiClient.callApi(
        '/api/v1/podtemplates', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1ReplicationControllerForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1ReplicationControllerForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationControllerList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ReplicationController
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1ReplicationControllerForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationControllerList}
     */
    listCoreV1ReplicationControllerForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ReplicationControllerList;
      return this.apiClient.callApi(
        '/api/v1/replicationcontrollers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1ResourceQuotaForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1ResourceQuotaForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuotaList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ResourceQuota
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1ResourceQuotaForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuotaList}
     */
    listCoreV1ResourceQuotaForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ResourceQuotaList;
      return this.apiClient.callApi(
        '/api/v1/resourcequotas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1SecretForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1SecretForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1SecretList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Secret
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1SecretForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1SecretList}
     */
    listCoreV1SecretForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1SecretList;
      return this.apiClient.callApi(
        '/api/v1/secrets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1ServiceAccountForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1ServiceAccountForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccountList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind ServiceAccount
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1ServiceAccountForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccountList}
     */
    listCoreV1ServiceAccountForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ServiceAccountList;
      return this.apiClient.callApi(
        '/api/v1/serviceaccounts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listCoreV1ServiceForAllNamespaces operation.
     * @callback module:api/CoreV1Api~listCoreV1ServiceForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * list or watch objects of kind Service
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~listCoreV1ServiceForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceList}
     */
    listCoreV1ServiceForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApiCoreV1ServiceList;
      return this.apiClient.callApi(
        '/api/v1/services', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    patchCoreV1Namespace(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1Namespace");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1Namespace");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespaceStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespaceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespaceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    patchCoreV1NamespaceStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespaceStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespaceStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ConfigMap}
     */
    patchCoreV1NamespacedConfigMap(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ConfigMap;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Endpoints}
     */
    patchCoreV1NamespacedEndpoints(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Endpoints;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Event}
     */
    patchCoreV1NamespacedEvent(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedEvent");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedEvent");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedEvent");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Event;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1LimitRange}
     */
    patchCoreV1NamespacedLimitRange(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1LimitRange;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    patchCoreV1NamespacedPersistentVolumeClaim(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedPersistentVolumeClaimStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedPersistentVolumeClaimStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedPersistentVolumeClaimStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    patchCoreV1NamespacedPersistentVolumeClaimStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedPersistentVolumeClaimStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedPersistentVolumeClaimStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedPersistentVolumeClaimStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    patchCoreV1NamespacedPod(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedPod");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedPod");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedPod");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedPodEphemeralcontainers operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedPodEphemeralcontainersCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update ephemeralcontainers of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedPodEphemeralcontainersCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    patchCoreV1NamespacedPodEphemeralcontainers(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedPodEphemeralcontainers");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedPodEphemeralcontainers");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedPodEphemeralcontainers");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedPodStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedPodStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedPodStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    patchCoreV1NamespacedPodStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedPodStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedPodStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedPodStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplate}
     */
    patchCoreV1NamespacedPodTemplate(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PodTemplate;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    patchCoreV1NamespacedReplicationController(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedReplicationControllerScale operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedReplicationControllerScaleCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiAutoscalingV1Scale} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update scale of the specified ReplicationController
     * @param {String} name name of the Scale
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedReplicationControllerScaleCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiAutoscalingV1Scale}
     */
    patchCoreV1NamespacedReplicationControllerScale(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedReplicationControllerScale");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedReplicationControllerScale");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedReplicationControllerScale");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiAutoscalingV1Scale;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedReplicationControllerStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedReplicationControllerStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedReplicationControllerStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    patchCoreV1NamespacedReplicationControllerStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedReplicationControllerStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedReplicationControllerStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedReplicationControllerStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    patchCoreV1NamespacedResourceQuota(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedResourceQuotaStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedResourceQuotaStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedResourceQuotaStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    patchCoreV1NamespacedResourceQuotaStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedResourceQuotaStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedResourceQuotaStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedResourceQuotaStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Secret}
     */
    patchCoreV1NamespacedSecret(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedSecret");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedSecret");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedSecret");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Secret;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    patchCoreV1NamespacedService(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedService");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedService");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedService");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccount}
     */
    patchCoreV1NamespacedServiceAccount(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ServiceAccount;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NamespacedServiceStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NamespacedServiceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NamespacedServiceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    patchCoreV1NamespacedServiceStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NamespacedServiceStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling patchCoreV1NamespacedServiceStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NamespacedServiceStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1Node operation.
     * @callback module:api/CoreV1Api~patchCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified Node
     * @param {String} name name of the Node
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    patchCoreV1Node(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1Node");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1Node");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1NodeStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1NodeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified Node
     * @param {String} name name of the Node
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1NodeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    patchCoreV1NodeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1NodeStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1NodeStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~patchCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    patchCoreV1PersistentVolume(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1PersistentVolume");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1PersistentVolume");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchCoreV1PersistentVolumeStatus operation.
     * @callback module:api/CoreV1Api~patchCoreV1PersistentVolumeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * partially update status of the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object.<String, Object>} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {Boolean} [force] Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param {module:api/CoreV1Api~patchCoreV1PersistentVolumeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    patchCoreV1PersistentVolumeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling patchCoreV1PersistentVolumeStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling patchCoreV1PersistentVolumeStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'force': opts['force']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json', 'application/apply-patch+yaml'];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}/status', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1ComponentStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1ComponentStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ComponentStatus} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ComponentStatus
     * @param {String} name name of the ComponentStatus
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1ComponentStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ComponentStatus}
     */
    readCoreV1ComponentStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1ComponentStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ComponentStatus;
      return this.apiClient.callApi(
        '/api/v1/componentstatuses/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    readCoreV1Namespace(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1Namespace");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespaceStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespaceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespaceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    readCoreV1NamespaceStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespaceStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ConfigMap}
     */
    readCoreV1NamespacedConfigMap(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ConfigMap;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Endpoints}
     */
    readCoreV1NamespacedEndpoints(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Endpoints;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Event}
     */
    readCoreV1NamespacedEvent(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedEvent");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedEvent");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Event;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1LimitRange}
     */
    readCoreV1NamespacedLimitRange(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1LimitRange;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    readCoreV1NamespacedPersistentVolumeClaim(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPersistentVolumeClaimStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPersistentVolumeClaimStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPersistentVolumeClaimStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    readCoreV1NamespacedPersistentVolumeClaimStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPersistentVolumeClaimStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPersistentVolumeClaimStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    readCoreV1NamespacedPod(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPod");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPod");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPodEphemeralcontainers operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPodEphemeralcontainersCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read ephemeralcontainers of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPodEphemeralcontainersCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    readCoreV1NamespacedPodEphemeralcontainers(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPodEphemeralcontainers");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPodEphemeralcontainers");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPodLog operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPodLogCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read log of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [container] The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * @param {Boolean} [follow] Follow the log stream of the pod. Defaults to false.
     * @param {Boolean} [insecureSkipTLSVerifyBackend] insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).
     * @param {Number} [limitBytes] If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {Boolean} [previous] Return previous terminated container logs. Defaults to false.
     * @param {Number} [sinceSeconds] A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * @param {Number} [tailLines] If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
     * @param {Boolean} [timestamps] If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPodLogCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    readCoreV1NamespacedPodLog(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPodLog");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPodLog");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'container': opts['container'],
        'follow': opts['follow'],
        'insecureSkipTLSVerifyBackend': opts['insecureSkipTLSVerifyBackend'],
        'limitBytes': opts['limitBytes'],
        'pretty': opts['pretty'],
        'previous': opts['previous'],
        'sinceSeconds': opts['sinceSeconds'],
        'tailLines': opts['tailLines'],
        'timestamps': opts['timestamps']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['text/plain', 'application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/log', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPodStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPodStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPodStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    readCoreV1NamespacedPodStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPodStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPodStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplate}
     */
    readCoreV1NamespacedPodTemplate(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PodTemplate;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    readCoreV1NamespacedReplicationController(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedReplicationControllerScale operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedReplicationControllerScaleCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiAutoscalingV1Scale} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read scale of the specified ReplicationController
     * @param {String} name name of the Scale
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedReplicationControllerScaleCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiAutoscalingV1Scale}
     */
    readCoreV1NamespacedReplicationControllerScale(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedReplicationControllerScale");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedReplicationControllerScale");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiAutoscalingV1Scale;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedReplicationControllerStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedReplicationControllerStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedReplicationControllerStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    readCoreV1NamespacedReplicationControllerStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedReplicationControllerStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedReplicationControllerStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    readCoreV1NamespacedResourceQuota(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedResourceQuotaStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedResourceQuotaStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedResourceQuotaStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    readCoreV1NamespacedResourceQuotaStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedResourceQuotaStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedResourceQuotaStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Secret}
     */
    readCoreV1NamespacedSecret(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedSecret");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedSecret");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Secret;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    readCoreV1NamespacedService(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedService");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedService");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccount}
     */
    readCoreV1NamespacedServiceAccount(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ServiceAccount;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NamespacedServiceStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NamespacedServiceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NamespacedServiceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    readCoreV1NamespacedServiceStatus(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NamespacedServiceStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling readCoreV1NamespacedServiceStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1Node operation.
     * @callback module:api/CoreV1Api~readCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    readCoreV1Node(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1Node");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1NodeStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1NodeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified Node
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1NodeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    readCoreV1NodeStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1NodeStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~readCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    readCoreV1PersistentVolume(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1PersistentVolume");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readCoreV1PersistentVolumeStatus operation.
     * @callback module:api/CoreV1Api~readCoreV1PersistentVolumeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * read status of the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~readCoreV1PersistentVolumeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    readCoreV1PersistentVolumeStatus(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling readCoreV1PersistentVolumeStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Namespace
     * @param {String} name name of the Namespace
     * @param {module:model/IoK8sApiCoreV1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    replaceCoreV1Namespace(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1Namespace");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1Namespace");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespaceFinalize operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespaceFinalizeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace finalize of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {module:model/IoK8sApiCoreV1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {module:api/CoreV1Api~replaceCoreV1NamespaceFinalizeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    replaceCoreV1NamespaceFinalize(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespaceFinalize");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespaceFinalize");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation'],
        'pretty': opts['pretty']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/finalize', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespaceStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespaceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Namespace} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Namespace
     * @param {String} name name of the Namespace
     * @param {module:model/IoK8sApiCoreV1Namespace} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespaceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Namespace}
     */
    replaceCoreV1NamespaceStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespaceStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespaceStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Namespace;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ConfigMap} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ConfigMap
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ConfigMap} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ConfigMap}
     */
    replaceCoreV1NamespacedConfigMap(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ConfigMap;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/configmaps/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Endpoints} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Endpoints
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Endpoints} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Endpoints}
     */
    replaceCoreV1NamespacedEndpoints(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Endpoints;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/endpoints/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Event} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Event
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Event} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Event}
     */
    replaceCoreV1NamespacedEvent(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedEvent");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedEvent");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedEvent");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Event;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/events/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1LimitRange} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified LimitRange
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1LimitRange} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1LimitRange}
     */
    replaceCoreV1NamespacedLimitRange(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1LimitRange;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/limitranges/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    replaceCoreV1NamespacedPersistentVolumeClaim(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedPersistentVolumeClaimStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedPersistentVolumeClaimStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified PersistentVolumeClaim
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1PersistentVolumeClaim} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedPersistentVolumeClaimStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolumeClaim}
     */
    replaceCoreV1NamespacedPersistentVolumeClaimStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolumeClaim;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    replaceCoreV1NamespacedPod(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedPod");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedPod");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedPod");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedPodEphemeralcontainers operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedPodEphemeralcontainersCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace ephemeralcontainers of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedPodEphemeralcontainersCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    replaceCoreV1NamespacedPodEphemeralcontainers(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedPodEphemeralcontainers");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedPodEphemeralcontainers");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedPodEphemeralcontainers");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedPodStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedPodStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Pod} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Pod
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Pod} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedPodStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Pod}
     */
    replaceCoreV1NamespacedPodStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedPodStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedPodStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedPodStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Pod;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/pods/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PodTemplate} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified PodTemplate
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1PodTemplate} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PodTemplate}
     */
    replaceCoreV1NamespacedPodTemplate(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PodTemplate;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/podtemplates/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ReplicationController} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    replaceCoreV1NamespacedReplicationController(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedReplicationControllerScale operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedReplicationControllerScaleCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiAutoscalingV1Scale} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace scale of the specified ReplicationController
     * @param {String} name name of the Scale
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiAutoscalingV1Scale} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedReplicationControllerScaleCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiAutoscalingV1Scale}
     */
    replaceCoreV1NamespacedReplicationControllerScale(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedReplicationControllerScale");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedReplicationControllerScale");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedReplicationControllerScale");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiAutoscalingV1Scale;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedReplicationControllerStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedReplicationControllerStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ReplicationController} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified ReplicationController
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ReplicationController} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedReplicationControllerStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ReplicationController}
     */
    replaceCoreV1NamespacedReplicationControllerStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedReplicationControllerStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedReplicationControllerStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedReplicationControllerStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ReplicationController;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    replaceCoreV1NamespacedResourceQuota(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedResourceQuotaStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedResourceQuotaStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified ResourceQuota
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ResourceQuota} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedResourceQuotaStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ResourceQuota}
     */
    replaceCoreV1NamespacedResourceQuotaStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedResourceQuotaStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedResourceQuotaStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedResourceQuotaStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ResourceQuota;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Secret} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Secret
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Secret} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Secret}
     */
    replaceCoreV1NamespacedSecret(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedSecret");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedSecret");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedSecret");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Secret;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/secrets/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Service} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    replaceCoreV1NamespacedService(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedService");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedService");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedService");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified ServiceAccount
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1ServiceAccount} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1ServiceAccount}
     */
    replaceCoreV1NamespacedServiceAccount(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1ServiceAccount;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/serviceaccounts/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NamespacedServiceStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NamespacedServiceStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Service} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Service
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {module:model/IoK8sApiCoreV1Service} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NamespacedServiceStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Service}
     */
    replaceCoreV1NamespacedServiceStatus(name, namespace, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NamespacedServiceStatus");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling replaceCoreV1NamespacedServiceStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NamespacedServiceStatus");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Service;
      return this.apiClient.callApi(
        '/api/v1/namespaces/{namespace}/services/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1Node operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified Node
     * @param {String} name name of the Node
     * @param {module:model/IoK8sApiCoreV1Node} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    replaceCoreV1Node(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1Node");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1Node");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1NodeStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1NodeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1Node} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified Node
     * @param {String} name name of the Node
     * @param {module:model/IoK8sApiCoreV1Node} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1NodeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1Node}
     */
    replaceCoreV1NodeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1NodeStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1NodeStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1Node;
      return this.apiClient.callApi(
        '/api/v1/nodes/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~replaceCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    replaceCoreV1PersistentVolume(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1PersistentVolume");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1PersistentVolume");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the replaceCoreV1PersistentVolumeStatus operation.
     * @callback module:api/CoreV1Api~replaceCoreV1PersistentVolumeStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * replace status of the specified PersistentVolume
     * @param {String} name name of the PersistentVolume
     * @param {module:model/IoK8sApiCoreV1PersistentVolume} body 
     * @param {Object} opts Optional parameters
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [dryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param {String} [fieldManager] fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param {String} [fieldValidation] fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param {module:api/CoreV1Api~replaceCoreV1PersistentVolumeStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApiCoreV1PersistentVolume}
     */
    replaceCoreV1PersistentVolumeStatus(name, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling replaceCoreV1PersistentVolumeStatus");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling replaceCoreV1PersistentVolumeStatus");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'pretty': opts['pretty'],
        'dryRun': opts['dryRun'],
        'fieldManager': opts['fieldManager'],
        'fieldValidation': opts['fieldValidation']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'];
      let returnType = IoK8sApiCoreV1PersistentVolume;
      return this.apiClient.callApi(
        '/api/v1/persistentvolumes/{name}/status', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1ConfigMapListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1ConfigMapListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1ConfigMapListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1ConfigMapListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/configmaps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1EndpointsListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1EndpointsListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1EndpointsListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1EndpointsListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/endpoints', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1EventListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1EventListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1EventListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1EventListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1LimitRangeListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1LimitRangeListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1LimitRangeListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1LimitRangeListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/limitranges', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1Namespace operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Namespace. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Namespace
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1Namespace(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1Namespace");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespaceList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespaceListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Namespace. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespaceListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespaceList(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedConfigMap operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedConfigMapCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind ConfigMap. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the ConfigMap
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedConfigMapCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedConfigMap(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedConfigMap");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedConfigMap");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/configmaps/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedConfigMapList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedConfigMapListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedConfigMapListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedConfigMapList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedConfigMapList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/configmaps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedEndpoints operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedEndpointsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Endpoints. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Endpoints
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedEndpointsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedEndpoints(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedEndpoints");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedEndpoints");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/endpoints/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedEndpointsList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedEndpointsListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedEndpointsListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedEndpointsList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedEndpointsList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/endpoints', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedEvent operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedEventCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Event
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedEventCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedEvent(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedEvent");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedEvent");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/events/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedEventList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedEventListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedEventListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedEventList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedEventList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedLimitRange operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedLimitRangeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind LimitRange. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the LimitRange
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedLimitRangeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedLimitRange(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedLimitRange");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedLimitRange");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/limitranges/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedLimitRangeList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedLimitRangeListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedLimitRangeListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedLimitRangeList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedLimitRangeList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/limitranges', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedPersistentVolumeClaim operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedPersistentVolumeClaimCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the PersistentVolumeClaim
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedPersistentVolumeClaimCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedPersistentVolumeClaim(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedPersistentVolumeClaim");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedPersistentVolumeClaim");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedPersistentVolumeClaimList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedPersistentVolumeClaimListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedPersistentVolumeClaimListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedPersistentVolumeClaimList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedPersistentVolumeClaimList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedPod operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedPodCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Pod. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Pod
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedPodCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedPod(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedPod");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedPod");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/pods/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedPodList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedPodListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedPodListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedPodList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedPodList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/pods', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedPodTemplate operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedPodTemplateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind PodTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the PodTemplate
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedPodTemplateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedPodTemplate(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedPodTemplate");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedPodTemplate");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/podtemplates/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedPodTemplateList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedPodTemplateListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedPodTemplateListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedPodTemplateList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedPodTemplateList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/podtemplates', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedReplicationController operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedReplicationControllerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind ReplicationController. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the ReplicationController
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedReplicationControllerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedReplicationController(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedReplicationController");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedReplicationController");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedReplicationControllerList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedReplicationControllerListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedReplicationControllerListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedReplicationControllerList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedReplicationControllerList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/replicationcontrollers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedResourceQuota operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedResourceQuotaCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the ResourceQuota
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedResourceQuotaCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedResourceQuota(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedResourceQuota");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedResourceQuota");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedResourceQuotaList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedResourceQuotaListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedResourceQuotaListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedResourceQuotaList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedResourceQuotaList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/resourcequotas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedSecret operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedSecretCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Secret
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedSecretCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedSecret(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedSecret");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedSecret");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/secrets/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedSecretList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedSecretListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedSecretListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedSecretList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedSecretList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/secrets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedService operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedServiceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Service. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Service
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedServiceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedService(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedService");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedService");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/services/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedServiceAccount operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedServiceAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the ServiceAccount
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedServiceAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedServiceAccount(name, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1NamespacedServiceAccount");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedServiceAccount");
      }

      let pathParams = {
        'name': name,
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedServiceAccountList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedServiceAccountListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedServiceAccountListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedServiceAccountList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedServiceAccountList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/serviceaccounts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NamespacedServiceList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NamespacedServiceListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {String} namespace object name and auth scope, such as for teams and projects
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NamespacedServiceListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NamespacedServiceList(namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling watchCoreV1NamespacedServiceList");
      }

      let pathParams = {
        'namespace': namespace
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/namespaces/{namespace}/services', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1Node operation.
     * @callback module:api/CoreV1Api~watchCoreV1NodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind Node. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the Node
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1Node(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1Node");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/nodes/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1NodeList operation.
     * @callback module:api/CoreV1Api~watchCoreV1NodeListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Node. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1NodeListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1NodeList(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/nodes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1PersistentVolume operation.
     * @callback module:api/CoreV1Api~watchCoreV1PersistentVolumeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param {String} name name of the PersistentVolume
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1PersistentVolumeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1PersistentVolume(name, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling watchCoreV1PersistentVolume");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/persistentvolumes/{name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1PersistentVolumeClaimListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1PersistentVolumeClaimListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1PersistentVolumeClaimListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1PersistentVolumeClaimListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/persistentvolumeclaims', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1PersistentVolumeList operation.
     * @callback module:api/CoreV1Api~watchCoreV1PersistentVolumeListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1PersistentVolumeListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1PersistentVolumeList(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/persistentvolumes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1PodListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1PodListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1PodListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1PodListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/pods', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1PodTemplateListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1PodTemplateListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1PodTemplateListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1PodTemplateListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/podtemplates', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1ReplicationControllerListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1ReplicationControllerListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1ReplicationControllerListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1ReplicationControllerListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/replicationcontrollers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1ResourceQuotaListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1ResourceQuotaListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1ResourceQuotaListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1ResourceQuotaListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/resourcequotas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1SecretListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1SecretListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1SecretListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1SecretListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/secrets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1ServiceAccountListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1ServiceAccountListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1ServiceAccountListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1ServiceAccountListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/serviceaccounts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the watchCoreV1ServiceListForAllNamespaces operation.
     * @callback module:api/CoreV1Api~watchCoreV1ServiceListForAllNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list operation instead.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [allowWatchBookmarks] allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param {String} [_continue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {String} [fieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param {String} [labelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param {Number} [limit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {String} [pretty] If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param {String} [resourceVersion] resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {String} [resourceVersionMatch] resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param {Boolean} [sendInitialEvents] `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
     * @param {Number} [timeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param {Boolean} [watch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param {module:api/CoreV1Api~watchCoreV1ServiceListForAllNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/IoK8sApimachineryPkgApisMetaV1WatchEvent}
     */
    watchCoreV1ServiceListForAllNamespaces(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'allowWatchBookmarks': opts['allowWatchBookmarks'],
        'continue': opts['_continue'],
        'fieldSelector': opts['fieldSelector'],
        'labelSelector': opts['labelSelector'],
        'limit': opts['limit'],
        'pretty': opts['pretty'],
        'resourceVersion': opts['resourceVersion'],
        'resourceVersionMatch': opts['resourceVersionMatch'],
        'sendInitialEvents': opts['sendInitialEvents'],
        'timeoutSeconds': opts['timeoutSeconds'],
        'watch': opts['watch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['BearerToken'];
      let contentTypes = [];
      let accepts = ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'];
      let returnType = IoK8sApimachineryPkgApisMetaV1WatchEvent;
      return this.apiClient.callApi(
        '/api/v1/watch/services', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
